{"ast":null,"code":"import moment from \"moment\";\nexport const generateTimeSvg = sortedTimeline => {\n  const adjustedModel = [];\n  const cumulativeModel = [];\n  const startYear = sortedTimeline[0].start.toDate().getFullYear();\n  var rowPointer = 0;\n\n  for (let i = 0; i < sortedTimeline.length; i++) {\n    //@ts-ignore\n    const end = moment(sortedTimeline[i].end === 'today' || sortedTimeline[i].end.toDate() > new Date() ? new Date() : sortedTimeline[i].end.toDate()).diff(moment(`01-01-${startYear}`, 'DD-MM-YYYY'), 'M');\n    const start = moment(sortedTimeline[i].start.toDate()).diff(moment(`01-01-${startYear}`, 'DD-MM-YYYY'), 'M');\n\n    for (let j = 0; j <= rowPointer; j++) {\n      if (!adjustedModel[j] || start > adjustedModel[j][adjustedModel[j].length - 1].end) {\n        if (!adjustedModel[j]) adjustedModel[j] = [];\n        let svgObj = {\n          id: sortedTimeline[i].id,\n          start: start,\n          end: end,\n          row: j\n        };\n        adjustedModel[j].push(svgObj);\n        cumulativeModel.push(svgObj);\n        rowPointer = 0;\n      } else rowPointer++;\n    }\n  }\n\n  return {\n    nrOfRows: Math.max.apply(Math, cumulativeModel.map(function (e) {\n      return e.row;\n    })),\n    svgModel: cumulativeModel\n  };\n};\nexport const generateStringSvg = startYear => {\n  const years = [];\n\n  for (let i = 0; i < new Date().getFullYear() - startYear + 1; i++) {\n    years.push(i + startYear);\n  }\n\n  return years;\n};","map":{"version":3,"sources":["/Users/friedebold/dev/potfolio/src/components/Timeline/svgGenerator.tsx"],"names":["moment","generateTimeSvg","sortedTimeline","adjustedModel","cumulativeModel","startYear","start","toDate","getFullYear","rowPointer","i","length","end","Date","diff","j","svgObj","id","row","push","nrOfRows","Math","max","apply","map","e","svgModel","generateStringSvg","years"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AAUA,OAAO,MAAMC,eAAe,GAAIC,cAAD,IAAkC;AAE/D,QAAMC,aAA2B,GAAG,EAApC;AACA,QAAMC,eAA2B,GAAG,EAApC;AAEA,QAAMC,SAAS,GAAGH,cAAc,CAAC,CAAD,CAAd,CAAkBI,KAAlB,CAAwBC,MAAxB,GAAiCC,WAAjC,EAAlB;AAEA,MAAIC,UAAU,GAAG,CAAjB;;AACA,OAAK,IAAIC,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGR,cAAc,CAACS,MAA3C,EAAmDD,CAAC,EAApD,EAAwD;AACtD;AACA,UAAME,GAAG,GAAGZ,MAAM,CAACE,cAAc,CAACQ,CAAD,CAAd,CAAkBE,GAAlB,KAA0B,OAA1B,IAAqCV,cAAc,CAACQ,CAAD,CAAd,CAAkBE,GAAlB,CAAsBL,MAAtB,KAAiC,IAAIM,IAAJ,EAAtE,GAAmF,IAAIA,IAAJ,EAAnF,GAAgGX,cAAc,CAACQ,CAAD,CAAd,CAAkBE,GAAlB,CAAsBL,MAAtB,EAAjG,CAAN,CAAuIO,IAAvI,CAA4Id,MAAM,CAAE,SAAQK,SAAU,EAApB,EAAuB,YAAvB,CAAlJ,EAAwL,GAAxL,CAAZ;AACA,UAAMC,KAAK,GAAGN,MAAM,CAACE,cAAc,CAACQ,CAAD,CAAd,CAAkBJ,KAAlB,CAAwBC,MAAxB,EAAD,CAAN,CAAyCO,IAAzC,CAA8Cd,MAAM,CAAE,SAAQK,SAAU,EAApB,EAAwB,YAAxB,CAApD,EAA2F,GAA3F,CAAd;;AACA,SAAK,IAAIU,CAAS,GAAG,CAArB,EAAwBA,CAAC,IAAIN,UAA7B,EAAyCM,CAAC,EAA1C,EAA8C;AAE5C,UAAI,CAACZ,aAAa,CAACY,CAAD,CAAd,IAAqBT,KAAK,GAAGH,aAAa,CAACY,CAAD,CAAb,CAAiBZ,aAAa,CAACY,CAAD,CAAb,CAAiBJ,MAAjB,GAA0B,CAA3C,EAA8CC,GAA/E,EAAoF;AAClF,YAAI,CAACT,aAAa,CAACY,CAAD,CAAlB,EAAuBZ,aAAa,CAACY,CAAD,CAAb,GAAmB,EAAnB;AACvB,YAAIC,MAAM,GAAG;AACXC,UAAAA,EAAE,EAAEf,cAAc,CAACQ,CAAD,CAAd,CAAkBO,EADX;AAEXX,UAAAA,KAAK,EAAEA,KAFI;AAGXM,UAAAA,GAAG,EAAEA,GAHM;AAIXM,UAAAA,GAAG,EAAEH;AAJM,SAAb;AAMAZ,QAAAA,aAAa,CAACY,CAAD,CAAb,CAAiBI,IAAjB,CAAsBH,MAAtB;AACAZ,QAAAA,eAAe,CAACe,IAAhB,CAAqBH,MAArB;AACAP,QAAAA,UAAU,GAAG,CAAb;AACD,OAXD,MAWOA,UAAU;AAClB;AACF;;AACD,SAAO;AACLW,IAAAA,QAAQ,EAAEC,IAAI,CAACC,GAAL,CAASC,KAAT,CAAeF,IAAf,EAAqBjB,eAAe,CAACoB,GAAhB,CAAoB,UAAUC,CAAV,EAAa;AAAE,aAAOA,CAAC,CAACP,GAAT;AAAc,KAAjD,CAArB,CADL;AAELQ,IAAAA,QAAQ,EAAEtB;AAFL,GAAP;AAID,CAhCM;AAkCP,OAAO,MAAMuB,iBAAiB,GAAItB,SAAD,IAAuB;AACtD,QAAMuB,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,IAAIG,IAAJ,GAAWL,WAAX,KAA2BH,SAA3B,GAAuC,CAA3D,EAA8DK,CAAC,EAA/D,EAAmE;AACjEkB,IAAAA,KAAK,CAACT,IAAN,CAAWT,CAAC,GAAGL,SAAf;AACD;;AACD,SAAOuB,KAAP;AACD,CANM","sourcesContent":["import moment from \"moment\"\nimport { Experience } from \"../../apis/model\"\n\ninterface SvgModel {\n  id: number,\n  start: number,\n  end: number,\n  row: number\n}\n\nexport const generateTimeSvg = (sortedTimeline: Experience[]) => {\n\n  const adjustedModel: SvgModel[][] = []\n  const cumulativeModel: SvgModel[] = []\n\n  const startYear = sortedTimeline[0].start.toDate().getFullYear()\n\n  var rowPointer = 0\n  for (let i: number = 0; i < sortedTimeline.length; i++) {\n    //@ts-ignore\n    const end = moment(sortedTimeline[i].end === 'today' || sortedTimeline[i].end.toDate() > new Date() ? new Date() : sortedTimeline[i].end.toDate()).diff(moment(`01-01-${startYear}`, 'DD-MM-YYYY'), 'M')\n    const start = moment(sortedTimeline[i].start.toDate()).diff(moment(`01-01-${startYear}`,  'DD-MM-YYYY'), 'M')\n    for (let j: number = 0; j <= rowPointer; j++) {\n\n      if (!adjustedModel[j] || start > adjustedModel[j][adjustedModel[j].length - 1].end) {\n        if (!adjustedModel[j]) adjustedModel[j] = []\n        let svgObj = {\n          id: sortedTimeline[i].id,\n          start: start,\n          end: end,\n          row: j\n        }\n        adjustedModel[j].push(svgObj)\n        cumulativeModel.push(svgObj)\n        rowPointer = 0\n      } else rowPointer++\n    }\n  }\n  return {\n    nrOfRows: Math.max.apply(Math, cumulativeModel.map(function (e) { return e.row })),\n    svgModel: cumulativeModel\n  }\n}\n\nexport const generateStringSvg = (startYear: number) => {\n  const years = []\n  for (let i = 0; i < new Date().getFullYear() - startYear + 1; i++) {\n    years.push(i + startYear)\n  }\n  return years\n}\n\n"]},"metadata":{},"sourceType":"module"}